# 给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。   返回这三个数的和。  假定每组输入只存在恰好一个解。
# 我的解法  排序+双指针
# 1.首先对数组进行排序，以便双指针的使用和重复数字的排除
# 2.固定第一个数，其他两个数用双指针不断移动计算并比较
# 3.若计算所得值大于target,则左移右指针，反之则右移左指针
# 4.不断比较 计算所得值 与target之差，若小于初始值之差则将该值赋值，直到双指针计算完所有三数之和后输出三数之和sum = nums[i] + nums[left] + nums[right]
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var threeSumClosest = function(nums, target) {
    nums.sort((a, b) => a - b); // 排序
    let n = nums.length;
    let closest = Infinity; // 保存最接近的和

    for (let i = 0; i < n - 2; i++) {
        let left = i + 1;
        let right = n - 1;

        while (left < right) {
            let sum = nums[i] + nums[left] + nums[right];

            // 如果比之前的更接近 target，就更新
            if (Math.abs(sum - target) < Math.abs(closest - target)) {
                closest = sum;
            }

            if (sum < target) {
                left++;
            } else if (sum > target) {
                right--;
            } else {
                // sum == target，已经最接近
                return sum;
            }
        }
    }

    return closest;
};

# 其他解法  排序 + 二分查找优化
# 固定前两个数找第三个数
# i和j固定 nums[i] + nums[j] + nums[k] ≈ target
# 第三个数remain = target - (nums[i] + nums[j])
# 如果 nums[mid] < remain，说明要找的数在右边；如果 nums[mid] > remain，说明要找的数在左边；每次比较时，更新当前最接近 target 的三数和。
var threeSumClosest = function(nums, target) {
    nums.sort((a, b) => a - b);
    let n = nums.length;
    let closest = Infinity;

    for (let i = 0; i < n - 2; i++) {
        for (let j = i + 1; j < n - 1; j++) {
            let remain = target - nums[i] - nums[j];
            // 在 nums[j+1, n-1] 之间找最接近 remain 的值
            let left = j + 1, right = n - 1;
            while (left <= right) {
                let mid = Math.floor((left + right) / 2);
                let sum = nums[i] + nums[j] + nums[mid];
                if (Math.abs(sum - target) < Math.abs(closest - target)) {
                    closest = sum;
                }
                if (nums[mid] < remain) left = mid + 1;
                else right = mid - 1;
            }
        }
    }
    return closest;
};
# 优点：思路清晰，稍快于 O(n³)。缺点：实现比双指针复杂，仍比 O(n²) 慢一些。